<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Farmer Chatbot ‚Äî ChatGPT-style UI</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#071427; --panel:#0b1522; --muted:#9fb0c8; --accent:#10b981; --glass: rgba(255,255,255,0.03); --card:#071427; --bubble-user:#dcf8c6; --bubble-assist:#ffffff; --radius:12px; }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#071427 0%, #081628 100%);font-family:Inter,system-ui,Arial;color:#e8f0f6;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
  .wrap{width:100%;max-width:1200px;display:grid;grid-template-columns:340px 1fr;gap:18px}
  .sidebar{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:16px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 12px 40px rgba(2,6,23,0.65)}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:52px;height:52px;border-radius:12px;background:linear-gradient(135deg,var(--accent),#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:800;color:#042}
  .brand .title{font-size:18px;font-weight:800;color:#e6ffe9}
  .sidebar .controls{margin-top:16px;display:flex;flex-direction:column;gap:8px}
  .btn{padding:10px 12px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .btn.primary{background:var(--accent);color:#042}
  select,input[type=text]{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:#e6f0f6}

  .saved-list{margin-top:12px;display:flex;flex-direction:column;gap:8px;max-height:36vh;overflow:auto}
  .saved-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px;border-radius:10px;background:rgba(255,255,255,0.01);cursor:pointer;border:1px solid rgba(255,255,255,0.02)}

  .panel{display:flex;flex-direction:column;gap:12px}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h2{margin:0;color:#c7f3d3}
  .status{display:flex;gap:10px;align-items:center;color:var(--muted);font-size:0.9rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.45)}
  .messages{height:60vh;overflow:auto;padding:18px;display:flex;flex-direction:column;gap:12px}
  .message{max-width:78%;padding:12px 14px;border-radius:14px;word-wrap:break-word;position:relative}
  .user{align-self:flex-end;background:var(--bubble-user);color:#064;text-align:right;border-bottom-right-radius:6px;box-shadow:0 8px 20px rgba(16,185,129,0.06)}
  .assistant{align-self:flex-start;background:var(--bubble-assist);color:#0b2535;border:1px solid #eee;border-bottom-left-radius:6px}
  .meta{font-size:0.75rem;color:var(--muted);margin-top:8px}
  .system-note{font-size:13px;color:var(--muted);padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01);display:inline-block}

  .composer{display:flex;gap:12px;align-items:center;padding:12px;border-radius:12px;background:var(--panel);border:1px solid rgba(255,255,255,0.03)}
  #userInput{flex:1;padding:12px;border-radius:999px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6f0f6;outline:none}
  .action-group{display:flex;gap:8px;align-items:center}
  .small-btn{padding:10px;border-radius:10px;border:none;cursor:pointer;background:rgba(255,255,255,0.03);color:#e6f0f6}
  .stop-btn{background:#ef4444;color:white;border-radius:10px;padding:10px 14px;border:none;cursor:pointer;font-weight:700;display:none}

  .fullAnswer{margin-top:6px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.02)}
  .formatted{margin-top:8px;padding:12px;border-radius:8px;background:#fff;color:#081;border:1px solid #eee;white-space:pre-wrap}
  .summary{margin-top:6px;padding:8px;border-radius:8px;background:#fffbe6;border:1px solid #ffecb3;font-weight:700;color:#5a4b00}

  .token-stream{font-family:monospace;font-size:0.9rem;padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);min-width:220px;max-width:420px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .controls-row{display:flex;gap:8px;align-items:center;margin-top:10px}

  @media (max-width:980px){ .wrap{grid-template-columns:1fr;padding:12px} .sidebar{order:2} }
</style>
</head>
<body>
<div class="wrap">
  <div class="sidebar">
    <div class="brand">
      <div class="logo">F</div>
      <div>
        <div class="title">Farmer Chatbot</div>
        <div style="font-size:12px;color:var(--muted)">Concise answers ‚Ä¢ voice-ready ‚Ä¢ multi-language</div>
      </div>
    </div>

    <div class="controls" style="margin-top:14px">
      <button id="newChat" class="btn ghost">+ New chat</button>
      <button id="saveChatBtn" class="btn ghost" title="Save current chat">üíæ Save chat</button>
      <button id="clearSavedBtn" class="btn ghost" title="Clear saved chats">üóëÔ∏è Clear saved</button>
    </div>

    <div style="margin-top:14px;font-size:13px;color:var(--muted)">Response length</div>
    <select id="brevitySelect" style="width:100%;margin-top:8px;background-color:#022;">
      <option value="short">Short (1‚Äì3 lines)</option>
      <option value="medium" selected>Medium (few bullets)</option>
      <option value="long">Long (detailed, but concise)</option>
    </select>

    <div style="margin-top:12px;font-size:13px;color:var(--muted)">TTS responsiveness</div>
    <div style="display:flex;flex-direction:column;gap:6px;margin-top:6px">
      <label style="font-size:12px;color:var(--muted)">Words per spoken chunk: <span id="chunkVal">8</span></label>
      <input id="chunkSlider" type="range" min="3" max="16" value="8" />
      <small style="color:var(--muted)">Lower ‚Üí starts speaking earlier. Higher ‚Üí longer continuous phrases.</small>
    </div>

    <div style="margin-top:14px;font-size:13px;color:var(--muted);">Preferred voice language (override)</div>
    <select id="langSelect" title="Override speech language" style="width:100%;margin-top:8px;background-color:#022;">
      <option value="auto">Auto (detect)</option>
      <option value="en-US">English (en-US)</option>
      <option value="hi-IN">Hindi (hi-IN)</option>
      <option value="ta-IN">Tamil (ta-IN)</option>
      <option value="te-IN">Telugu (te-IN)</option>
      <option value="kn-IN">Kannada (kn-IN)</option>
      <option value="fr-FR">French (fr-FR)</option>
      <option value="es-ES">Spanish (es-ES)</option>
    </select>

    <div style="margin-top:18px;font-size:13px;color:var(--muted)">Status</div>
    <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
      <div id="locStatus" class="system-note">Location: detecting‚Ä¶</div>
      <div id="weatherStatus" class="system-note" style="display:none"></div>
      <div id="timeStatus" class="system-note" style="display:none"></div>
    </div>

    <div style="margin-top:14px;font-size:13px;color:var(--muted)">Saved chats</div>
    <div id="savedList" class="saved-list"></div>
    <div id="noSaved" style="margin-top:8px;color:var(--muted);font-size:13px">No saved chats yet</div>
  </div>

  <div class="panel">
    <div class="topbar">
      <div style="display:flex;gap:12px;align-items:center">
        <h2>Ask the Farmer AI</h2>
        <div class="status"><div class="system-note">Short, crisp, structured replies</div></div>
      </div>

      <div style="display:flex;gap:10px;align-items:center">
        <div id="typing" class="system-note" style="display:none">Assistant preparing a voice reply‚Ä¶</div>
        <div id="tokenStream" class="token-stream" title="Live streaming preview">‚Äî</div>
      </div>
    </div>

    <div class="card messages" id="messages">
      <% messages.forEach(msg => { %>
        <div class="message <%= msg.role %> <%= msg.role==='user' ? 'user' : 'assistant' %>">
	          <% if (msg.role === 'user') { %>
	            <div style="font-size: 14px; font-weight: 600; color: #064;">You:</div>
	          <% } else { %>
	            <div style="font-size: 14px; font-weight: 600; color: #0b2535;">Assistant:</div>
	          <% } %>
	          <% const safeText = escape(msg.text).replace(/\n/g, '<br>'); %>
	          <div style="margin-top:8px; line-height: 1.6; font-size: 1.05rem;"><%= safeText %></div>
          <div class="meta"><%= new Date(msg.createdAt).toLocaleString() %> (<%= msg.language %>)</div>
        </div>
      <% }) %>
    </div>

    <div class="composer">
      <input type="text" id="userInput" placeholder="Ask your question..." autocomplete="off" />
      <div class="action-group">
        <button id="startMic" class="small-btn" title="Speak">üé§</button>
        <button id="sendBtn" class="btn primary" type="button">Send</button>
        <button id="stopBtn" class="stop-btn" title="Stop generation">Stop</button>
      </div>
    </div>
  </div>
</div>
<script>
// ===== DOM =====
const messagesDiv = document.getElementById('messages');
const userInput = document.getElementById('userInput');
const typingDiv = document.getElementById('typing');
const startMic = document.getElementById('startMic');
const newChatBtn = document.getElementById('newChat');
const saveChatBtn = document.getElementById('saveChatBtn');
const clearSavedBtn = document.getElementById('clearSavedBtn');
const savedList = document.getElementById('savedList');
const noSaved = document.getElementById('noSaved');
const locStatus = document.getElementById('locStatus');
const langSelect = document.getElementById('langSelect');
const sendBtn = document.getElementById('sendBtn');
const stopBtn = document.getElementById('stopBtn');
const tokenStream = document.getElementById('tokenStream');
const brevitySelect = document.getElementById('brevitySelect');
const chunkSlider = document.getElementById('chunkSlider');
const chunkVal = document.getElementById('chunkVal');

let currentLocation = null;
let voicesReady = false;
let availableVoices = [];
let stopRequested = false;
let currentFetchController = null;

// tts queue/status
const ttsQueue = [];
let ttsBusy = false;

// dynamic chunk size (client-side ref)
let CLIENT_WORDS_THRESHOLD = parseInt(chunkSlider.value || '8', 10);

// language helpers
const normalizeMap = { eng:'en-US', hin:'hi-IN', ta:'ta-IN', tel:'te-IN', kn:'kn-IN', fra:'fr-FR', spa:'es-ES' };
const indianLanguages = ['hi-IN','ta-IN','te-IN','kn-IN'];
const languageFriendly = { 'en-US':'English', 'hi-IN':'Hindi', 'ta-IN':'Tamil', 'te-IN':'Telugu', 'kn-IN':'Kannada', 'fr-FR':'French', 'es-ES':'Spanish' };
const unknownLangMsg = {
  'en-US': "I don't know that language.",
  'hi-IN': "‡§Æ‡•Å‡§ù‡•á ‡§µ‡§π ‡§≠‡§æ‡§∑‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§§‡•Ä‡•§",
  'ta-IN': "‡Æé‡Æ©‡Æï‡Øç‡Æï‡ØÅ ‡ÆÖ‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Øä‡Æ¥‡Æø ‡Æ§‡ØÜ‡Æ∞‡Æø‡ÆØ‡Ææ‡Æ§‡ØÅ.",
  'te-IN': "‡∞®‡∞æ‡∞ï‡±Å ‡∞Ü ‡∞≠‡∞æ‡∞∑ ‡∞§‡±Ü‡∞≤‡∞ø‡∞Ø‡∞¶‡±Å.",
  'kn-IN': "‡≤®‡≤®‡≤ó‡≥Ü ‡≤Ü ‡≤≠‡≤æ‡≤∑‡≥Ü ‡≤§‡≤ø‡≤≥‡≤ø‡≤¶‡≤ø‡≤≤‡≥ç‡≤≤.",
  'fr-FR': "Je ne connais pas cette langue.",
  'es-ES': "No conozco ese idioma."
};

// server-chunking flag and dedupe helper
let serverChunking = false;
let lastSpokenImmediate = '';

// --- TTS Logic ---
function loadVoices() {
  return new Promise(resolve => {
    const check = () => {
      availableVoices = window.speechSynthesis.getVoices();
      if (availableVoices.length > 0) {
        voicesReady = true;
        resolve();
      } else setTimeout(check, 100);
    };
    window.speechSynthesis.onvoiceschanged = check;
    check();
  });
}

function getVoice(locale) {
    if (!voicesReady) return null;
    const normLocale = String(locale || '').replace('_','-');

    // Exact match
    let voice = availableVoices.find(v => v.lang.toLowerCase() === normLocale.toLowerCase());
    if (voice) return voice;

    // Try any Indian voice
    voice = availableVoices.find(v => ['hi-IN','ta-IN','te-IN','kn-IN'].includes(v.lang));
    if (voice) return voice;

    // Fallback to English
    return availableVoices.find(v => v.lang === 'en-US') || availableVoices[0];
}


function speak(text, locale) {
  if (!window.speechSynthesis || !voicesReady) return;
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.voice = getVoice(locale);
  utterance.lang = utterance.voice ? utterance.voice.lang : locale;
  window.speechSynthesis.speak(utterance);
  return utterance;
}

function speakAndWait(text, locale) {
  return new Promise(resolve => {
    const utterance = speak(text, locale);
    if (!utterance) return resolve();
    utterance.onend = () => resolve();
    utterance.onerror = () => resolve();
  });
}

function enqueueTTS(text, locale) {
  ttsQueue.push({ text, locale });
  processTTSQueue();
}

function enqueueTTSImmediate(text, locale) {
  ttsQueue.unshift({ text, locale });
  processTTSQueue();
}

function processTTSQueue() {
  if (ttsBusy || ttsQueue.length === 0) return;
  ttsBusy = true;
  const { text, locale } = ttsQueue.shift();
  const utterance = speak(text, locale);
  if (!utterance) { ttsBusy = false; if (ttsQueue.length>0) processTTSQueue(); return; }

  utterance.onend = () => {
    ttsBusy = false;
    if (!currentFetchController && ttsQueue.length === 0) setUiBusy(false,false);
    if (ttsQueue.length>0) processTTSQueue();
  };
  utterance.onerror = (e) => { console.error('TTS error:', e); ttsBusy=false; processTTSQueue(); };
}

function cancelTTS() {
  window.speechSynthesis.cancel();
  ttsQueue.length = 0;
  ttsBusy = false;
  lastSpokenImmediate = '';
}

// --- Utility ---
function escapeHtml(unsafe) {
  return unsafe.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
}
function normalizeLang(lang) {
  if (!lang) return null;
  const norm = lang.toLowerCase().split('-')[0];
  return normalizeMap[norm] || lang;
}
function getPreferredSpeechLocale(assistantLangRaw) {
  const selectedLang = langSelect.value;
  if (selectedLang !== 'auto') return selectedLang;
  const assistantNorm = normalizeLang(assistantLangRaw);
  return assistantNorm || (navigator.language || 'en-US');
}
function appendMessage(role, text, createdAt, language) {
  const d = document.createElement('div');
  d.className = 'message ' + (role==='user'?'user':'assistant');
  d.innerHTML = `${role==='user'?'<strong>You:</strong>':''}
                 <div style="margin-top:8px">${escapeHtml(text).replace(/\n/g,'<br>')}</div>
                 <div class="meta">${escapeHtml(createdAt)} (${languageFriendly[language] || language})</div>`;
  messagesDiv.appendChild(d);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}
function setUiBusy(isFetching, isSpeaking){
  const busy = isFetching || isSpeaking;
  userInput.disabled=busy;
  sendBtn.style.display=busy?'none':'block';
  stopBtn.style.display=busy?'block':'none';
  typingDiv.style.display=isFetching?'block':'none';
  startMic.disabled=busy;
  newChatBtn.disabled=busy;
  saveChatBtn.disabled=busy;
  clearSavedBtn.disabled=busy;
}

// --- Streaming ---
let fullReply='', ttsBuffer='', assistantLangRaw=null, bodyDiv=null, hasStrippedPrefix=false;

function handleStreamingToken(token, language) {
  // Strip any prefix like "Assistant: " or "Seva: "
  if (!hasStrippedPrefix) {
    const prefixRegex = /^(Assistant|Seva):\s*/i;
    const combined = fullReply + token;
    if (prefixRegex.test(combined)) {
      token = combined.replace(prefixRegex, '');
      fullReply = '';
      hasStrippedPrefix = true;
    } else if (combined.length > 20) {
      hasStrippedPrefix = true;
    }
  }

  fullReply += token;

  // Remove already spoken immediate text from buffer to avoid duplicates
  if (serverChunking && lastSpokenImmediate && ttsBuffer.startsWith(lastSpokenImmediate)) {
    ttsBuffer = ttsBuffer.substring(lastSpokenImmediate.length);
  }

  ttsBuffer += token;

  // Update UI
  bodyDiv.innerHTML = escapeHtml(fullReply).replace(/\n/g,'<br>');
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
  tokenStream.textContent = fullReply.trim().slice(0,220) + (fullReply.trim().length>220 ? '‚Ä¶' : '');

  // CLIENT-SIDE CHUNKING (only if server NOT doing sentence_partial)
  if (!serverChunking) {
    const words = ttsBuffer.replace(/[\s\n]+/g, ' ').trim().split(' ').filter(Boolean);
    if (words.length >= CLIENT_WORDS_THRESHOLD) {
      const lastSpace = ttsBuffer.lastIndexOf(' ');
      let chunkToSpeak = ttsBuffer;
      let remainder = '';

      if (lastSpace > -1) {
        chunkToSpeak = ttsBuffer.substring(0, lastSpace + 1);
        remainder = ttsBuffer.substring(lastSpace + 1);
      }

      if (chunkToSpeak.trim()) {
        const localeToSpeak = getPreferredSpeechLocale(language);
        enqueueTTS(chunkToSpeak.trim(), localeToSpeak);
        ttsBuffer = remainder;
      }
    }
  }
}


function cancelOngoing(){
  stopRequested=true;
  if(currentFetchController) currentFetchController.abort();
  cancelTTS();
  lastSpokenImmediate='';
  setUiBusy(false,false);
  if(fullReply.trim()) bodyDiv.innerHTML=escapeHtml(fullReply).replace(/\n/g,'<br>');
  tokenStream.textContent='‚Äî';
}

// --- Send and streaming ---
async function sendStreamed(prompt){
  if(currentFetchController) return;
  cancelTTS();
  const scriptLocale=navigator.language||'en-US';
  const metaTime=new Date().toLocaleString();
  const langOverride=langSelect.value||'auto';
  let userLang = langOverride!=='auto'?langOverride:'en-US';
  appendMessage('user',prompt,metaTime,userLang);

  fullReply=''; ttsBuffer=''; assistantLangRaw=null; stopRequested=false; serverChunking=false; lastSpokenImmediate='';
  currentFetchController=new AbortController();
  setUiBusy(true,false);
  tokenStream.textContent='...';
  hasStrippedPrefix=false;

  const assistantDiv=document.createElement('div');
  assistantDiv.className='message assistant';
  assistantDiv.innerHTML=`<div id="streamingBody"></div><div class="meta">${metaTime} (detecting language...)</div>`;
  messagesDiv.appendChild(assistantDiv);
  bodyDiv = assistantDiv.querySelector('#streamingBody');
  const metaDiv = assistantDiv.querySelector('.meta');

  const payload={ prompt, location:currentLocation, langOverride, brevity:brevitySelect.value, speechChunkWords:CLIENT_WORDS_THRESHOLD };

  try{
    const response=await fetch('/stream',{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload), signal:currentFetchController.signal });
    if(!response.ok){ const errorText=await response.text(); bodyDiv.innerHTML=`Error: ${escapeHtml(errorText)}`; setUiBusy(false,false); return; }

    const reader=response.body.getReader();
    const decoder=new TextDecoder();
    let buffer='';

    while(true){
      if(stopRequested) break;
      const {value, done}=await reader.read();
      if(value){
        buffer+=decoder.decode(value,{stream:true});
        let idx;
        while((idx=buffer.indexOf('\n\n'))!==-1){
          if(stopRequested) break;
          const block=buffer.slice(0,idx).trim();
          buffer=buffer.slice(idx+2);
          const lines=block.split('\n').map(l=>l.trim()).filter(Boolean);
          const dataLine=lines.find(l=>l.startsWith('data:'));
          if(!dataLine) continue;

          let obj;
          try{ obj=JSON.parse(dataLine.replace(/^data:\s*/,'')); }catch(e){ console.warn('Failed to parse SSE data',dataLine,e); continue; }

          if(typeof obj.server_chunking!=='undefined') serverChunking=!!obj.server_chunking;

          if(obj.token){
            assistantLangRaw=assistantLangRaw||obj.language||userLang||scriptLocale;
            metaDiv.textContent=`${metaTime} (${languageFriendly[getPreferredSpeechLocale(assistantLangRaw)]||getPreferredSpeechLocale(assistantLangRaw)})`;
            handleStreamingToken(obj.token, assistantLangRaw);
          }

          if(obj.sentence_partial){
            const s=obj.sentence_partial.trim();
            if(s && s!==lastSpokenImmediate){
              lastSpokenImmediate=s;
              const localeToSpeak=getPreferredSpeechLocale(obj.language||assistantLangRaw);
              enqueueTTSImmediate(s, localeToSpeak);
              if(serverChunking && ttsBuffer.startsWith(s)) ttsBuffer=ttsBuffer.substring(s.length).trim();
            }
          }

          if(obj.error){
            if(obj.error==='aborted'){ stopRequested=true; cancelOngoing(); break; }
            bodyDiv.innerHTML+=`<br>Error: ${escapeHtml(obj.error)}`;
          }

          if(obj.done){
            stopRequested=false;
            currentFetchController=null;
            if(ttsBuffer.trim()){ enqueueTTSImmediate(ttsBuffer.trim(),getPreferredSpeechLocale(assistantLangRaw)); ttsBuffer=''; }
            const trimmed=fullReply.trim();
            if(!trimmed){ const norm=normalizeLang(scriptLocale||userLang)||'en-US'; const msg=unknownLangMsg[norm]||unknownLangMsg['en-US']; appendMessage('Assistant',msg,metaTime,norm); setUiBusy(false,false); await speakAndWait(msg,norm); tokenStream.textContent='‚Äî'; return; }
            setUiBusy(false, ttsBusy||ttsQueue.length>0);
            tokenStream.textContent=fullReply.trim().slice(0,220)+(fullReply.trim().length>220?'‚Ä¶':'');
            return;
          }
        }
      }
      if(done) break;
    }
  }catch(e){
    if(e && e.name!=='AbortError'){ console.error('stream read error',e); bodyDiv.innerHTML+=`<br>Error during stream: ${escapeHtml(String(e.message||e))}`; }
  }finally{ currentFetchController=null; }

  setUiBusy(false, ttsBusy||ttsQueue.length>0);
  if(fullReply.trim()){ bodyDiv.innerHTML=escapeHtml(fullReply).replace(/\n/g,'<br>'); if(ttsBuffer.trim()){ enqueueTTSImmediate(ttsBuffer.trim(), getPreferredSpeechLocale(assistantLangRaw)); ttsBuffer=''; } tokenStream.textContent=fullReply.trim().slice(0,220)+(fullReply.trim().length>220?'‚Ä¶':''); }
  else{ const norm=normalizeLang(scriptLocale||userLang)||'en-US'; const msg=unknownLangMsg[norm]||unknownLangMsg['en-US']; appendMessage('Assistant',msg,new Date().toLocaleString(),norm); await speakAndWait(msg,norm); tokenStream.textContent='‚Äî'; }
}

// --- Mic ---
startMic.addEventListener('click', async ()=>{
  const Rec=window.SpeechRecognition||window.webkitSpeechRecognition;
  if(!Rec){ alert('Speech recognition not supported.'); return; }
  const rec=new Rec();
  const recLang=(langSelect.value && langSelect.value!=='auto') ? langSelect.value : (navigator.language||'en-US');
  rec.lang=recLang;
  rec.interimResults=false;
  rec.maxAlternatives=1;

  startMic.textContent='Listening...';
  rec.onend=()=>startMic.textContent='üé§';
  rec.onerror=()=>startMic.textContent='üé§';

  rec.onresult=async ev=>{ const t=ev.results[0][0].transcript; await sendStreamed(t); };
  rec.start();
});

// --- Send button ---
async function handleSend(){
  const t=userInput.value.trim();
  if(!t) return;
  userInput.value='';
  await sendStreamed(t);
}
sendBtn.addEventListener('click',e=>{ e.preventDefault(); if(getComputedStyle(stopBtn).display!=='none') return; handleSend(); });
userInput.addEventListener('keydown',async e=>{ if(e.key==='Enter'&&!e.shiftKey){ e.preventDefault(); if(getComputedStyle(stopBtn).display!=='none') return; handleSend(); } });
stopBtn.addEventListener('click',e=>{ e.preventDefault(); cancelOngoing(); });

// --- New chat ---
newChatBtn.addEventListener('click',async ()=>{
  if(!confirm('Clear chat history and memory on server and local view?')) return;
  try{
    const resp=await fetch('/new-chat',{ method:'POST', headers:{'Content-Type':'application/json'} });
    if(!resp.ok) throw new Error('Server error');
    messagesDiv.innerHTML=''; tokenStream.textContent='‚Äî';
    alert('Server and local chat cleared.');
  }catch(e){ console.error(e); alert('Failed to clear server chat ‚Äî check server logs.'); }
});

// --- Saved chats ---
const SAVED_KEY = 'farmer_chat_saved_sessions_v1';

function loadSavedChats(){
  try{
    const raw = localStorage.getItem(SAVED_KEY);
    return raw ? JSON.parse(raw) : [];
  }catch(e){
    return [];
  }
}

function saveSavedChats(arr){
  try{ localStorage.setItem(SAVED_KEY, JSON.stringify(arr)); } catch(e){}
}

function renderSavedList(){
  const arr = loadSavedChats();
  savedList.innerHTML = '';
  if(!arr.length){
    noSaved.style.display = 'block';
    return;
  }
  noSaved.style.display = 'none';
  // newest first
  arr.slice().reverse().forEach(item=>{
    const el = document.createElement('div');
    el.className = 'saved-item';
    el.innerHTML = `<div>
                      <div class="title">${escapeHtml(item.title || 'Chat')}</div>
                      <small>${escapeHtml(new Date(item.createdAt).toLocaleString())}</small>
                    </div>
                    <div class="saved-actions">
                      <button title="Load" data-id="${item.id}" class="load-btn">‚ñ∂</button>
                      <button title="Delete" data-id="${item.id}" class="del-btn">‚úñ</button>
                    </div>`;
    savedList.appendChild(el);
  });

  // attach events
  Array.from(savedList.querySelectorAll('.load-btn')).forEach(b=>{
    b.addEventListener('click', (ev)=>{
      const id = b.getAttribute('data-id');
      loadSavedChat(id);
    });
  });
  Array.from(savedList.querySelectorAll('.del-btn')).forEach(b=>{
    b.addEventListener('click', (ev)=>{
      const id = b.getAttribute('data-id');
      deleteSavedChat(id);
    });
  });
}


function saveCurrentChat(){
  // read messages in DOM (user + assistant)
  const nodes = Array.from(messagesDiv.querySelectorAll('.message'));
  if(!nodes.length){
    alert('Nothing to save ‚Äî the chat is empty.');
    return;
  }
  const items = nodes.map(n=>{
    const role = n.classList.contains('user') ? 'user' : 'assistant';
    const txt = n.querySelector('div') ? n.querySelector('div').innerText : n.innerText;
    const meta = n.querySelector('.meta') ? n.querySelector('.meta').innerText : '';
    return { role, text: txt, meta };
  });
  const arr = loadSavedChats();
  const id = 's_' + Date.now();
  const title = items.filter(i=>i.role==='user').slice(-1)[0]?.text?.slice(0,60) || 'Chat';
  const entry = { id, title, createdAt: Date.now(), items };
  arr.push(entry);
  saveSavedChats(arr);
  renderSavedList();
  alert('Chat saved locally in sidebar.');
}

function loadSavedChat(id){
  const arr = loadSavedChats();
  const entry = arr.find(a=>a.id===id);
  if(!entry){ alert('Saved chat not found'); return; }
  // clear current view and render entry
  messagesDiv.innerHTML = '';
  entry.items.forEach(it=>{
    const d = document.createElement('div');
    d.className = 'message ' + (it.role === 'user' ? 'user' : 'assistant');
    const created = (it.meta && it.meta.match(/\d{1,2}\/\d{1,2}\/\d{4}/)) ? it.meta : new Date().toLocaleString();
    d.innerHTML = `<strong>${it.role === 'user' ? 'You' : 'Assistant'}:</strong>
                   <div style="margin-top:8px">${escapeHtml(it.text).replace(/\n/g,'<br>')}</div>
                   <div class="meta">${escapeHtml(created)}</div>`;
    messagesDiv.appendChild(d);
  });
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
  fullAnswerContainer.innerHTML = '';
}

function deleteSavedChat(id){
  let arr = loadSavedChats();
  arr = arr.filter(a=>a.id!==id);
  saveSavedChats(arr);
  renderSavedList();
}

clearSavedBtn.addEventListener('click', ()=>{
  if(!confirm('Delete all saved chats from localStorage?')) return;
  localStorage.removeItem(SAVED_KEY);
  renderSavedList();
});

saveChatBtn.addEventListener('click', ()=>{
  saveCurrentChat();
});

// init saved list
renderSavedList();

clearSavedBtn.addEventListener('click', ()=>{ if(confirm('Delete all saved chats?')){ localStorage.removeItem(SAVED_KEY); renderSavedList(); } });
saveChatBtn.addEventListener('click', ()=>{ saveCurrentChat(); });
renderSavedList();

chunkSlider.addEventListener('input', ()=>{ chunkVal.textContent=chunkSlider.value; CLIENT_WORDS_THRESHOLD=parseInt(chunkSlider.value,10); });

// --- Init ---
window.addEventListener('load', async ()=>{
  if(window.speechSynthesis) await loadVoices();
  initAutoDetect();
});

async function initAutoDetect() {
  locStatus.textContent = 'Location: detecting‚Ä¶';

  currentLocation = await getLocationPromise();

  if (!currentLocation) {
    locStatus.textContent = 'Location: unavailable (allow location/time)';
    return;
  }

  locStatus.textContent = `Location: ${currentLocation.lat.toFixed(4)}, ${currentLocation.lon.toFixed(4)}`;

  // Optionally, you can also initialize other data here, e.g., time, weather, or language
  // Example: get current time at user's location
  const now = new Date();
  timeStatus.textContent = `Local time: ${now.toLocaleTimeString()}`;
}

// Helper to get geolocation
async function getLocationPromise() {
  return new Promise(resolve => {
    if (!navigator.geolocation) return resolve(null);

    navigator.geolocation.getCurrentPosition(
      (pos) => {
        resolve({
          lat: pos.coords.latitude,
          lon: pos.coords.longitude,
        });
      },
      (err) => {
        console.warn('Geolocation error:', err);
        resolve(null);
      },
      { timeout: 5000, enableHighAccuracy: false }
    );
  });
}
async function getWeather(lat, lon) {
  const API_KEY = OPENWEATHERMAP_API_KEY; // replace with your key
  if (!lat || !lon) return null;

  try {
    const resp = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${API_KEY}`);
    if (!resp.ok) throw new Error('Weather API error');
    const data = await resp.json();
    return {
      temp: data.main.temp,
      description: data.weather[0].description,
      city: data.name,
    };
  } catch (e) {
    console.error('Weather fetch failed', e);
    return null;
  }
}
async function initAutoDetect() {
  locStatus.textContent = 'Detecting location‚Ä¶';
  currentLocation = await getLocationPromise();

  if (!currentLocation) {
    locStatus.textContent = 'Location unavailable';
    weatherStatus.textContent = '';
    return;
  }

  locStatus.textContent = `Lat: ${currentLocation.lat.toFixed(4)}, Lon: ${currentLocation.lon.toFixed(4)}`;

  const weather = await getWeather(currentLocation.lat, currentLocation.lon);
  if (weather) {
    weatherStatus.textContent = `${weather.city}: ${weather.temp}¬∞C, ${weather.description}`;
  } else {
    weatherStatus.textContent = 'Weather unavailable';
  }
}



</script>

</body>
</html>
